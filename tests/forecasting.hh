#include <robots_core/board.hh>
#include <robots_core/forecasting.hh>

#include <iostream>
#include <cassert>
#include <algorithm>

namespace robots_core {
namespace tests {

struct ForecastingTests {

  static void run(){
    bool const passed = test_none_killed()
      && test_killable()
      ;

    if( passed ) std::cout << "PASSED ForecastingTests" << std::endl;
    else         std::cout << "FAILED ForecastingTests" << std::endl;
  }

  static bool test_none_killed(){
    Board const b("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000033033000000000000000000000000000000000000000000000000000000000000000000000000000000000000000330000000000000000000000000000000000000000000000000000000000000000000000000000000000000030003000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000033000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001020000000303000000000000000000000000000000000300000000000000000000000000000300000000000000000000000000000030000000000000000000000300000000003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000003000003000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000000300000300000000000000000003000000000000000000000000000300000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000");

    std::array< std::array< ForecastResults, 3 >, 3 > const all_forecasts =
      forecast_all_moves( b );

    assert( all_forecasts[ 0 ][ 0 ] == forecast_move( b, -1, -1 ) );

    for( sm_int dx = -1; dx <= 1; ++dx ){
      for( sm_int dy = -1; dy <= 1; ++dy ){
	ForecastResults const & f = all_forecasts[ dx+1 ][ dy+1 ];
	assert( f == forecast_move( b, dx, dy ) );

	assert( f.legal == (dy >= 0) );
	assert( f.cascade_safe == (dx == -1 and dy == 1) );

	assert( f.robots_killed == 0 );
      }
    }
    
    return true;
  }

  static bool test_killable(){
    Board const b("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000003000000000000000000002310111000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000001000010000003000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" );

    std::array< std::array< ForecastResults, 3 >, 3 > const all_forecasts =
      forecast_all_moves( b );

    assert( all_forecasts[ 0 ][ 0 ] == forecast_move( b, -1, -1 ) );

    for( sm_int dx = -1; dx <= 1; ++dx ){
      for( sm_int dy = -1; dy <= 1; ++dy ){
	ForecastResults const & f = all_forecasts[ dx+1 ][ dy+1 ];
	assert( f == forecast_move( b, dx, dy ) );

	assert( f.legal == (dy <= 0) );
	assert( not f.cascade_safe );

	if( dy <= 0 ){
	  if( dx < 0 ) assert( f.robots_killed == 1 );
	  else         assert( f.robots_killed == 2 );
	}
      }
    }
    
    return true;
  }


};

} //tests
} //robots_core
