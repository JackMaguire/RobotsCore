#include <robots_core/board.hh>

#include <iostream>
#include <cassert>
#include <algorithm>

namespace robots_core {
namespace tests {

namespace {
void assert_boards_equal( Board const & b1, Board const & b2 ){
  for( sm_int i = 0; i < Board::WIDTH; ++i ){
    for( sm_int j = 0; j < Board::HEIGHT; ++j ){
      Position const p({i,j});
      assert( b1.cell( p ) == b2.cell( p ) );
    }
  }    
}
}

struct BoardTests {

  static void run(){
    Board const b( "300000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000010000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" );

    bool const passed = test_deserialization( b )
      && test_cell_is_safe_for_teleport( b )
      && test_move( b )
      && test_move_is_cascade_safe()
      && test_safe_tele()
      && test_danger_tele()
      ;

    if( passed ) std::cout << "PASSED BoardTests" << std::endl;
    else         std::cout << "FAILED BoardTests" << std::endl;
  }

  static bool test_deserialization( Board const & b ){
    assert( b.n_robots() == 10 );
    assert( b.human_position().x == 23 );
    assert( b.human_position().y == 15 );

    Board::PositionVec expected_robots_positions({
	{2, 1},
	{7, 4},
	{7, 22},
	{15, 24},
	{18, 17},
	{18, 7},
	{26, 24},
	{28, 9},
	{34, 17},
	{36, 11}
      });

    assert( expected_robots_positions.size() == b.robots().size() );

    for( Position const & ep : expected_robots_positions ){
      auto iter = std::find( b.robots().begin(), b.robots().end(), ep );
      //auto iter = std::ranges::find( b.robots(), ep );
      assert( iter != b.robots().end() );  
    }

    for( sm_int i = 0; i < Board::WIDTH; ++i ){
      for( sm_int j = 0; j < Board::HEIGHT; ++j ){
	Position const p({i,j});

	assert( b.position_is_in_bounds( p ) );
	assert( b.cell( i, j ) == b.cell( p ) );

	bool const should_be_robot = std::find( expected_robots_positions.begin(), expected_robots_positions.end(), p ) != expected_robots_positions.end();

	if( should_be_robot ){
	  assert( b.cell( p ) == Occupant::ROBOT );
	} else if( i == 23 and j == 15 ){
	  assert( b.cell( p ) == Occupant::HUMAN );
	} else if( i == 0 and j == 0 ){
	  assert( b.cell( p ) == Occupant::FIRE );
	} else {
	  assert( b.cell( p ) == Occupant::EMPTY );
	}
      }
    }

    assert( not b.position_is_in_bounds( { -1, 0 } ) );
    assert( not b.position_is_in_bounds( { 0, -1 } ) );

    return true;
  }

  static bool test_cell_is_safe_for_teleport( Board const & b ){

    // ==true and ==false are okay here
    assert( b.cell_is_safe_for_teleport({ 0, 0 }) == false ); //fire
    assert( b.cell_is_safe_for_teleport({ 0, 1 }) == true  );

    assert( b.cell_is_safe_for_teleport({ 23, 15 }) == true  ); //human pos, not near robot

    assert( b.cell_is_safe_for_teleport({ 18, 17 }) == false ); //robot pos
    assert( b.cell_is_safe_for_teleport({ 18, 18 }) == false ); //next to robot pos

    return true;
  }

  static bool test_move( Board const & b ){

    //move the human one down, take one step

    Board const b_expected( "300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000001000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" );

    Board b_actual( b );
    MoveResult const outcome = b_actual.move_human( 0, -1 ); //calls move_robots_1_step

    assert( outcome == MoveResult::CONTINUE );

    assert( b_actual.n_robots() == b_expected.n_robots() );
    assert( b_actual.human_position() == b_expected.human_position() );
    assert_boards_equal( b_actual, b_expected );

    return true;
  }

  static bool test_move_is_cascade_safe(){
    // ==true and ==false are okay here

    Board const b( "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000033033000000000000000000000000000000000000000000000000000000000000000000000000000000000000000330000000000000000000000000000000000000000000000000000000000000000000000000000000000000030003000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000033000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001020000000303000000000000000000000000000000000300000000000000000000000000000300000000000000000000000000000030000000000000000000000300000000003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000003000003000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000000300000300000000000000000003000000000000000000000000000300000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000" );

    assert( b.move_is_cascade_safe( 0, 0 )  == false );
    assert( b.move_is_cascade_safe( -1, 1 ) == true );
    assert( b.move_is_cascade_safe( -1, 0 ) == false );
    assert( b.move_is_cascade_safe( 0, 1 )  == false );
    assert( b.move_is_cascade_safe( 0, -1 ) == false );

    assert( b.get_safe_moves() == "001000000" );

    return true;
  }

  static bool test_safe_tele(){
    Board b( "001111111111111111111111111111001111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111131111111111111111111111111111111111111111111111111111111111133133111111111111111111111111111111111111111111111111111111111111111111111111111111111111111331111111111111111111111111111111111111111111111111111011111111111111111111111111111111131113111111111111111111111111111111111111111111111111111111113111111111111111111111111111111111111111111111111111111011133111111111111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111111121111111313111111111111111111111111111111111311111111111111111111111111111311111111111111111111111111111131111111111111111111111311111111113111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111131111111111111111111111111111111111111111111111111111111111311111111111111111111111111111111111111111111111111111111113111113111111111111111111111111111111111111111111111111111311111111111111111111111111111111111111111111111111111111111111111311111311111111111111111113111111111111111111111111111311111111111111111111111111111111111111111111111131111111111111111111111111111111111111111111111111111111111111111" );

    //0,0 is the only open spot
    Position const p = b.find_open_space( true );
    assert( p.x == 0 );
    assert( p.y == 0 );    

    assert( b.teleport( true ) == MoveResult::CONTINUE );

    return true;
  }

  static bool test_danger_tele(){
    Board b( "101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111131111111111111111111111111111111111111111111111111111111111133133111111111111111111111111111111111111111111111111111111111111111111111111111111111111111331111111111111111111111111111111111111111111111111111111111111111111111111111111111111131113111111111111111111111111111111111111111111111111111111113111111111111111111111111111111111111111111111111111111111133111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111121111111313111111111111111111111111111111111311111111111111111111111111111311111111111111111111111111111131111111111111111111111311111111113111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111131111111111111111111111111111111111111111111111111111111111311111111111111111111111111111111111111111111111111111111113111113111111111111111111111111111111111111111111111111111311111111111111111111111111111111111111111111111111111111111111111311111311111111111111111113111111111111111111111111111311111111111111111111111111111111111111111111111131111111111111111111111111111111111111111111111111111111111111111" );

    // no open spaces
    Position const p = b.find_open_space( true );
    //expect this to fall back to b.find_open_space( false )
    assert( p.x == 0 );
    assert( p.y == 1 );    

    assert( b.teleport( false ) == MoveResult::YOU_LOSE );

    return true;
  }

};

} //tests
} //robots_core
